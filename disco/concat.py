import csv
import os

from Bio import AlignIO
from Bio.Align import MultipleSeqAlignment
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
import treeswift as ts

from disco.decomp import *


def retrieve_alignment(tree, aln_path, format, taxa_set, label_to_species):
    """
    Parameters
    ----------------
    tree: single-copy treeswift tree generated by DISCO.
    aln_path: path to the PHYLIP formatted alignment of the genes.
        The row labels should be a superset of the leafset of 'tree'.
    format: file format of the alignment (either "phylip" or "fasta").
    taxa_set: set, the taxon set of the entire dataset
    delimiter: delimiter used to get the taxa names from the labels

    Returns the MSA that corresponds to the input tree.
    """
    aln = AlignIO.read(open(aln_path), format)
    seq_len = len(aln[0].seq)
    blank = "-" * seq_len
    whitelist, remaining = set(tree.labels(True, False)), set(taxa_set)
    result = MultipleSeqAlignment([])

    # you can't get sequences by name from aln objects in biopython
    # in a better way as far as I can tell
    for record in aln[:, :seq_len]:
        if record.id in whitelist:
            taxon_name = label_to_species(record.id)
            result.append(SeqRecord(record.seq, id=taxon_name))
            remaining.remove(taxon_name)

    for taxon_name in remaining:
        result.append(SeqRecord(Seq(blank), id=str(taxon_name)))

    result.sort()
    return result


def concat_main(
    input_file_name: str,
    alignment_file_name: str,
    output_prefix: str,
    delimiter: str,
    format: str,
    filter: int = 2,
    partition: bool = False,
):
    input_alignments = [row for row in csv.reader(open(alignment_file_name, "r"))]
    label_to_species = lambda x: x.split(delimiter)[0]
    tree_list = ts.read_tree_newick(input_file_name)
    assert not isinstance(tree_list, ts.Tree)
    taxa_set = set(
        label
        for tree in tree_list
        for label in map(label_to_species, tree.labels(True, False))
    )

    # init aln with taxa labels
    aln = MultipleSeqAlignment([])
    for taxa in taxa_set:
        aln.append(SeqRecord(Seq(""), id=taxa))
    aln.sort()

    partitions = []
    p_index = 1

    for (aln_file, *_), tree in zip(input_alignments, tree_list):
        tree.reroot(get_min_root(tree, label_to_species)[0])
        tag(tree, label_to_species)
        disco_trees = list(
            filter(lambda x: x.num_nodes(internal=False) >= filter, decompose(tree))
        )
        for dtree in disco_trees:
            aln += retrieve_alignment(
                dtree, aln_file, format, taxa_set, label_to_species
            )
        if aln.get_alignment_length() + 1 != p_index:
            partitions.append(f"{p_index:d}-{aln.get_alignment_length():d}")
            p_index = aln.get_alignment_length() + 1
        else:
            partitions.append("empty")

    if partition:
        with open(f"{output_prefix}-partitions.txt", "w") as f:
            assert all(
                len(x) == 2 for x in input_alignments
            ), "alignment list file format problem"
            for partition, (aln_file, model) in zip(partitions, input_alignments):
                if partition != "empty":
                    gene_name = aln_file.split(os.sep)[-1].split(".")[0]
                    f.write(f"{model}, {gene_name}={partition}\n")

    AlignIO.write(aln, f"{output_prefix}-aln.{format[:3]}", format)
